# .github/workflows/ci-cd-study.yml
# Este Ã© o arquivo que o GitHub Actions lÃª para saber o que fazer
# Pense nele como uma "receita" que ensina ao GitHub como processar seu cÃ³digo

name: ğŸ“ Pipeline CI/CD de Estudos - Vue.js

# QUANDO executar este pipeline?
# Ã‰ como definir "quando a mÃ¡quina deve acordar e trabalhar"
on:
  push:
    branches: [main, develop] # Toda vez que vocÃª enviar cÃ³digo para estas branches
    paths-ignore: # MAS ignore mudanÃ§as apenas nestes arquivos
      - 'README.md' # MudanÃ§as no README nÃ£o precisam triggar deploy
      - 'docs/**' # DocumentaÃ§Ã£o tambÃ©m nÃ£o

  pull_request:
    branches: [main] # Toda vez que alguÃ©m abrir um PR para main

  # Permite executar manualmente atravÃ©s da interface do GitHub
  workflow_dispatch: # BotÃ£o "Run workflow" na aba Actions
    inputs:
      environment:
        description: 'Ambiente para deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

# VARIÃVEIS GLOBAIS que todos os jobs podem usar
# Como variÃ¡veis de ambiente que ficam disponÃ­veis para todo mundo
env:
  NODE_VERSION: '24' # VersÃ£o do Node.js que vamos usar
  CACHE_KEY_PREFIX: 'vue-cicd-study-v1' # Prefix para identificar nosso cache

# JOBS sÃ£o as "tarefas grandes" que queremos executar
# Pense em cada job como um computador virtual separado fazendo uma parte do trabalho
jobs:
  # JOB 1: PreparaÃ§Ã£o e validaÃ§Ã£o bÃ¡sica
  # Este job Ã© como uma "inspeÃ§Ã£o inicial" - verifica se tudo estÃ¡ ok para prosseguir
  setup-and-validate:
    name: ğŸ” Setup e ValidaÃ§Ã£o Inicial
    runs-on: ubuntu-latest # Sistema operacional do computador virtual

    # OUTPUTS: informaÃ§Ãµes que este job vai passar para outros jobs
    outputs:
      cache-hit: ${{ steps.cache.outputs.cache-hit }}
      package-hash: ${{ steps.package-hash.outputs.hash }}

    steps:
      # STEP 1: Buscar o cÃ³digo do repositÃ³rio
      # Ã‰ como "baixar o projeto" para o computador virtual
      - name: ğŸ“ Checkout do cÃ³digo
        uses: actions/checkout@v4 # Action oficial do GitHub para baixar cÃ³digo

      # STEP 2: Calcular hash do package.json
      # Hash Ã© como uma "impressÃ£o digital" do arquivo
      # Se o package.json nÃ£o mudou, podemos reutilizar cache de dependÃªncias
      - name: ğŸ”¢ Calcular hash do package.json
        id: package-hash # ID para referenciar este step depois
        run: |
          HASH=$(sha256sum package.json package-lock.json | sha256sum | cut -d' ' -f1)
          echo "hash=$HASH" >> $GITHUB_OUTPUT
          echo "ğŸ’¡ Hash calculado: $HASH"

      # STEP 3: Configurar Node.js
      - name: âš™ï¸ Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm' # GitHub Actions vai automaticamente cachear node_modules

      # STEP 4: Tentar restaurar cache de dependÃªncias
      - name: ğŸ’¾ Cache de dependÃªncias
        id: cache
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ env.CACHE_KEY_PREFIX }}-${{ steps.package-hash.outputs.hash }}
          restore-keys: |
            ${{ env.CACHE_KEY_PREFIX }}-

      # STEP 5: Instalar dependÃªncias (sÃ³ se nÃ£o tiver cache)
      - name: ğŸ“¦ Instalar dependÃªncias
        if: steps.cache.outputs.cache-hit != 'true' # SÃ³ executa se nÃ£o achou cache
        run: |
          echo "ğŸ”„ Cache nÃ£o encontrado, instalando dependÃªncias..."
          npm ci                    # npm ci Ã© mais rÃ¡pido e seguro para CI

      # STEP 6: ValidaÃ§Ãµes bÃ¡sicas
      - name: âœ… ValidaÃ§Ãµes bÃ¡sicas
        run: |
          echo "ğŸ” Verificando estrutura do projeto..."

          # Verificar se arquivos importantes existem
          if [ ! -f "package.json" ]; then
            echo "âŒ package.json nÃ£o encontrado!"
            exit 1
          fi

          if [ ! -f "src/main.js" ] && [ ! -f "src/main.ts" ]; then
            echo "âŒ Arquivo main.js ou main.ts nÃ£o encontrado!"
            exit 1
          fi

          if [ ! -d "src/components" ]; then
            echo "âš ï¸ Pasta src/components nÃ£o encontrada"
          fi

          echo "âœ… Estrutura do projeto validada!"

          # Mostrar informaÃ§Ãµes Ãºteis
          echo "ğŸ“Š InformaÃ§Ãµes do projeto:"
          echo "   ğŸ“ Nome: $(node -p "require('./package.json').name")"
          echo "   ğŸ”¢ VersÃ£o: $(node -p "require('./package.json').version")"
          echo "   ğŸ“¦ DependÃªncias: $(node -p "Object.keys(require('./package.json').dependencies || {}).length")"
          echo "   ğŸ› ï¸ DevDependencies: $(node -p "Object.keys(require('./package.json').devDependencies || {}).length")"

  # JOB 2: VerificaÃ§Ã£o de qualidade do cÃ³digo
  # Este job Ã© como ter um "revisor de cÃ³digo automatizado"
  code-quality:
    name: ğŸ” Qualidade do CÃ³digo
    runs-on: ubuntu-latest
    needs: setup-and-validate # Este job SÃ“ executa se o anterior passou

    steps:
      - name: ğŸ“ Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      # Restaurar dependÃªncias do cache criado no job anterior
      - name: ğŸ’¾ Restaurar cache de dependÃªncias
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ env.CACHE_KEY_PREFIX }}-${{ needs.setup-and-validate.outputs.package-hash }}

      # Se por algum motivo nÃ£o tiver cache, instalar dependÃªncias
      - name: ğŸ“¦ Instalar dependÃªncias (fallback)
        if: needs.setup-and-validate.outputs.cache-hit != 'true'
        run: npm ci

      # Executar linting (verificaÃ§Ã£o de cÃ³digo)
      - name: ğŸ” ESLint - VerificaÃ§Ã£o de cÃ³digo
        run: |
          echo "ğŸ” Executando ESLint para verificar qualidade do cÃ³digo..."
          echo "ğŸ“‹ Verificando:"
          echo "   - Sintaxe JavaScript/TypeScript"
          echo "   - PadrÃµes de cÃ³digo Vue.js"
          echo "   - VariÃ¡veis nÃ£o utilizadas"
          echo "   - PossÃ­veis bugs"
          echo "   - ConsistÃªncia de formataÃ§Ã£o"

          # Em um projeto real, seria: npm run lint
          # Para estudos, vamos simular:
          npm run simulate:lint

          echo "âœ… VerificaÃ§Ã£o de cÃ³digo concluÃ­da!"

      # Verificar formataÃ§Ã£o do cÃ³digo
      - name: ğŸ’… Prettier - VerificaÃ§Ã£o de formataÃ§Ã£o
        run: |
          echo "ğŸ’… Verificando formataÃ§Ã£o do cÃ³digo..."
          echo "ğŸ“‹ Analisando:"
          echo "   - IndentaÃ§Ã£o consistente"
          echo "   - Aspas simples vs duplas"
          echo "   - Quebras de linha"
          echo "   - EspaÃ§amento"

          # Simular verificaÃ§Ã£o de formataÃ§Ã£o
          echo "âœ… FormataÃ§Ã£o estÃ¡ consistente!"

      # AnÃ¡lise de seguranÃ§a bÃ¡sica
      - name: ğŸ›¡ï¸ Audit de seguranÃ§a
        run: |
          echo "ğŸ›¡ï¸ Executando auditoria de seguranÃ§a..."
          npm audit --audit-level=high
          echo "âœ… Auditoria concluÃ­da!"

  # JOB 3: Testes automatizados
  # Este Ã© onde "testamos se nossa aplicaÃ§Ã£o realmente funciona"
  tests:
    name: ğŸ§ª Testes Automatizados
    runs-on: ubuntu-latest
    needs: setup-and-validate

    # STRATEGY permite executar o mesmo job em diferentes configuraÃ§Ãµes
    # Ã‰ como testar em diferentes cenÃ¡rios
    strategy:
      matrix:
        test-type: [unit, integration] # Executar testes unitÃ¡rios e integraÃ§Ã£o separadamente

    steps:
      - name: ğŸ“ Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ’¾ Restaurar dependÃªncias
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ env.CACHE_KEY_PREFIX }}-${{ needs.setup-and-validate.outputs.package-hash }}

      - name: ğŸ“¦ Instalar dependÃªncias (fallback)
        if: needs.setup-and-validate.outputs.cache-hit != 'true'
        run: npm ci

      # Executar testes baseado no tipo da matrix
      - name: ğŸ§ª Executar testes ${{ matrix.test-type }}
        run: |
          if [ "${{ matrix.test-type }}" = "unit" ]; then
            echo "ğŸ”¬ Executando testes unitÃ¡rios..."
            echo "ğŸ“‹ Testando componentes individuais:"
            echo "   - RenderizaÃ§Ã£o correta"
            echo "   - Props e eventos"
            echo "   - MÃ©todos e computed"
            echo "   - Lifecycle hooks"
            
            # npm run test:unit
            npm run simulate:tests
            
          elif [ "${{ matrix.test-type }}" = "integration" ]; then
            echo "ğŸ”— Executando testes de integraÃ§Ã£o..."
            echo "ğŸ“‹ Testando interaÃ§Ã£o entre componentes:"
            echo "   - ComunicaÃ§Ã£o parent-child"
            echo "   - Store/State management"
            echo "   - Roteamento"
            echo "   - APIs mockadas"
            
            # Simular testes de integraÃ§Ã£o
            echo "âœ… Testes de integraÃ§Ã£o passaram!"
          fi

      # Upload dos resultados de teste para poder ver depois
      - name: ğŸ“Š Upload resultados dos testes
        uses: actions/upload-artifact@v4
        if: always() # Sempre fazer upload, mesmo se testes falharam
        with:
          name: test-results-${{ matrix.test-type }}
          path: |
            coverage/
            test-results/

  # JOB 4: Testes End-to-End
  # Simula um usuÃ¡rio real usando a aplicaÃ§Ã£o
  e2e-tests:
    name: ğŸ­ Testes End-to-End
    runs-on: ubuntu-latest
    needs: [setup-and-validate, code-quality] # Precisa que dois jobs passem

    steps:
      - name: ğŸ“ Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ’¾ Restaurar dependÃªncias
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ env.CACHE_KEY_PREFIX }}-${{ needs.setup-and-validate.outputs.package-hash }}

      - name: ğŸ“¦ Instalar dependÃªncias (fallback)
        if: needs.setup-and-validate.outputs.cache-hit != 'true'
        run: npm ci

      - name: ğŸ­ Executar testes E2E
        run: |
          echo "ğŸ­ Iniciando testes End-to-End..."
          echo "ğŸ”„ O que aconteceria:"
          echo "   1. Subir servidor de desenvolvimento (npm run serve)"
          echo "   2. Aguardar aplicaÃ§Ã£o ficar online"
          echo "   3. Abrir navegador automatizado (Cypress)"
          echo "   4. Executar cenÃ¡rios de uso real"

          # npm run test:e2e
          npm run simulate:e2e

      # Salvar screenshots e vÃ­deos se testes falharem
      - name: ğŸ“¸ Upload screenshots/videos
        uses: actions/upload-artifact@v4
        if: failure() # SÃ³ se testes E2E falharam
        with:
          name: e2e-artifacts
          path: |
            cypress/screenshots/
            cypress/videos/

  # JOB 5: Build de produÃ§Ã£o
  # Prepara a aplicaÃ§Ã£o para ser enviada aos usuÃ¡rios
  build:
    name: ğŸ—ï¸ Build de ProduÃ§Ã£o
    runs-on: ubuntu-latest
    needs: [tests, e2e-tests] # SÃ³ faz build se testes passaram

    outputs:
      build-version: ${{ steps.version.outputs.version }}

    steps:
      - name: ğŸ“ Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ’¾ Restaurar dependÃªncias
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ env.CACHE_KEY_PREFIX }}-${{ needs.setup-and-validate.outputs.package-hash }}

      - name: ğŸ“¦ Instalar dependÃªncias (fallback)
        if: needs.setup-and-validate.outputs.cache-hit != 'true'
        run: npm ci

      # Gerar nÃºmero da versÃ£o (baseado na data/commit)
      - name: ğŸ”¢ Gerar versÃ£o do build
        id: version
        run: |
          # Usar timestamp + commit curto como versÃ£o
          VERSION=$(date +'%Y%m%d.%H%M').$(git rev-parse --short HEAD)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ VersÃ£o do build: $VERSION"

      # Executar build de produÃ§Ã£o
      - name: ğŸ—ï¸ Build da aplicaÃ§Ã£o
        run: |
          echo "ğŸ—ï¸ Iniciando build de produÃ§Ã£o..."
          echo "âš™ï¸ ConfiguraÃ§Ãµes:"
          echo "   NODE_ENV=production"
          echo "   OtimizaÃ§Ãµes ativadas"
          echo "   Source maps habilitados"

          # npm run build (real)
          npm run simulate:build

          echo "âœ… Build concluÃ­do!"

          # Mostrar informaÃ§Ãµes sobre os arquivos gerados
          if [ -d "dist" ]; then
            echo "ğŸ“Š Arquivos gerados:"
            du -sh dist/* 2>/dev/null || echo "   (pasta dist nÃ£o encontrada na simulaÃ§Ã£o)"
          fi

      # Executar testes no build de produÃ§Ã£o
      - name: ğŸ” Validar build de produÃ§Ã£o
        run: |
          echo "ğŸ” Validando build de produÃ§Ã£o..."
          echo "âœ“ Verificando se index.html existe"
          echo "âœ“ Verificando se assets foram gerados"
          echo "âœ“ Verificando se nÃ£o hÃ¡ links quebrados"
          echo "âœ“ Validando estrutura de arquivos"
          echo "âœ… Build vÃ¡lido!"

      # Salvar arquivos do build para usar no deploy
      - name: ğŸ“¦ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files-${{ steps.version.outputs.version }}
          path: dist/
          retention-days: 30 # Manter arquivos por 30 dias

  # JOB 6: Deploy para Staging
  # Ambiente de teste que simula produÃ§Ã£o
  deploy-staging:
    name: ğŸš€ Deploy para Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop' || github.event_name == 'pull_request'

    environment:
      name: staging # GitHub Environment para aprovaÃ§Ãµes/proteÃ§Ãµes
      url: https://staging.meu-projeto.com

    steps:
      - name: ğŸ“ Checkout do cÃ³digo
        uses: actions/checkout@v4

      # Baixar arquivos do build
      - name: ğŸ“¦ Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-files-${{ needs.build.outputs.build-version }}
          path: dist/

      - name: ğŸš€ Simular deploy para staging
        run: |
          echo "ğŸš€ Iniciando deploy para STAGING..."
          echo "ğŸ¯ Ambiente: Staging"
          echo "ğŸŒ URL: https://staging.meu-projeto.com"
          echo "ğŸ“¦ VersÃ£o: ${{ needs.build.outputs.build-version }}"

          npm run simulate:deploy

          echo "âœ… Deploy para staging concluÃ­do!"

      # Executar smoke tests no staging
      - name: ğŸ’¨ Smoke tests no staging
        run: |
          echo "ğŸ’¨ Executando smoke tests..."
          echo "âœ“ Verificar se site carrega (HTTP 200)"
          echo "âœ“ Verificar se JavaScript nÃ£o tem erros"
          echo "âœ“ Verificar se CSS carregou corretamente"
          echo "âœ“ Verificar se pode fazer login (se aplicÃ¡vel)"
          echo "âœ… Smoke tests passaram!"

      # Notificar equipe sobre deploy
      - name: ğŸ“§ Notificar equipe
        run: |
          echo "ğŸ“§ NotificaÃ§Ã£o enviada:"
          echo "   ğŸ“ Para: #desenvolvimento (Slack/Teams/Discord)"
          echo "   ğŸ“ Mensagem: Deploy staging concluÃ­do"
          echo "   ğŸ”— Link: https://staging.meu-projeto.com"
          echo "   ğŸ†” VersÃ£o: ${{ needs.build.outputs.build-version }}"

  # JOB 7: Deploy para ProduÃ§Ã£o
  # SÃ³ executa na branch main e pode precisar de aprovaÃ§Ã£o manual
  deploy-production:
    name: ğŸŒŸ Deploy para ProduÃ§Ã£o
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'

    environment:
      name: production # GitHub Environment com proteÃ§Ãµes
      url: https://meu-projeto.com

    steps:
      - name: ğŸ“ Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ“ print needs
        run: |
          echo "ğŸ“ Iniciando checkout do cÃ³digo..."
          echo "needs ${{ needs }}"
          echo "needs.build ${{ needs.build }}"
          echo "needs.build.outputs ${{ needs.build.outputs }}"
          echo "needs.build.outputs.build ${{ needs.build.outputs.build }}"
          echo "needs.build.outputs.build-version ${{ needs.build.outputs.build-version }}"

      # - name: ğŸ“¦ Download build artifacts
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: build-files-${{ needs.build.outputs.build-version }}
      #     path: dist/

      # Backup do deploy anterior (estratÃ©gia de rollback)
      - name: ğŸ’¾ Backup deploy anterior
        run: |
          echo "ğŸ’¾ Fazendo backup do deploy anterior..."
          echo "ğŸ“ Movendo arquivos atuais para backup/"
          echo "ğŸ·ï¸ Tag de backup: backup-$(date +'%Y%m%d-%H%M%S')"
          echo "âœ… Backup criado!"

      - name: ğŸŒŸ Deploy para PRODUÃ‡ÃƒO
        run: |
          echo "ğŸŒŸ Iniciando deploy para PRODUÃ‡ÃƒO..."
          echo "âš ï¸ ATENÃ‡ÃƒO: Deploy em ambiente de produÃ§Ã£o!"
          echo "ğŸ¯ Ambiente: Production"
          echo "ğŸŒ URL: https://meu-projeto.com"
          echo "ğŸ“¦ VersÃ£o: ${{ needs.build.outputs.build-version }}"

          echo "ğŸš€ EstratÃ©gias de deploy disponÃ­veis:"
          echo "   1. ğŸ”µ Blue-Green: Deploy paralelo + switch"
          echo "   2. ğŸ³ Rolling: AtualizaÃ§Ã£o gradual"
          echo "   3. ğŸš« Recreate: Para tudo + sobe novo"

          npm run simulate:deploy

          echo "âœ… Deploy para produÃ§Ã£o concluÃ­do!"

      # Testes pÃ³s-deploy crÃ­ticos
      - name: ğŸ” Health checks pÃ³s-deploy
        run: |
          echo "ğŸ” Executando health checks crÃ­ticos..."
          echo "âœ“ Site responde (200 OK)"
          echo "âœ“ Tempo de resposta < 2s"
          echo "âœ“ Funcionalidades crÃ­ticas funcionando"
          echo "âœ“ Base de dados conectada"
          echo "âœ“ APIs externas acessÃ­veis"
          echo "âœ“ SSL certificate vÃ¡lido"
          echo "âœ… Todos os health checks passaram!"

      # Warming up do cache
      - name: ğŸ”¥ Cache warming
        run: |
          echo "ğŸ”¥ Aquecendo caches..."
          echo "âœ“ Pre-loading pÃ¡ginas principais"
          echo "âœ“ Cache de assets estÃ¡tico"
          echo "âœ“ Cache de API endpoints"
          echo "âœ… Caches aquecidos!"

      # Monitoramento pÃ³s-deploy
      - name: ğŸ“Š Ativar monitoramento
        run: |
          echo "ğŸ“Š Ativando monitoramento intensivo..."
          echo "ğŸ‘€ Observando por 30 minutos:"
          echo "   - Taxa de erro"
          echo "   - Tempo de resposta"
          echo "   - Uso de recursos"
          echo "   - Logs de erro"
          echo "âœ… Monitoramento ativado!"

      # NotificaÃ§Ãµes importantes
      - name: ğŸ‰ Notificar sucesso do deploy
        run: |
          echo "ğŸ‰ DEPLOY PRODUÃ‡ÃƒO CONCLUÃDO!"
          echo "ğŸ“§ NotificaÃ§Ãµes enviadas:"
          echo "   ğŸ“ Slack: #releases"
          echo "   ğŸ“ Email: stakeholders"
          echo "   ğŸ“ SMS: oncall-engineer"
          echo "ğŸ“Š Detalhes:"
          echo "   ğŸ†” VersÃ£o: ${{ needs.build.outputs.build-version }}"
          echo "   â±ï¸ DuraÃ§Ã£o: ~3 minutos"
          echo "   ğŸŒ URL: https://meu-projeto.com"
          echo "   ğŸ”„ Rollback: DisponÃ­vel se necessÃ¡rio"

  # JOB 8: Monitoramento pÃ³s-deploy
  # Monitora a aplicaÃ§Ã£o por um tempo apÃ³s o deploy
  post-deploy-monitoring:
    name: ğŸ“Š Monitoramento PÃ³s-Deploy
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: github.ref == 'refs/heads/main'

    steps:
      - name: ğŸ“Š Monitoramento contÃ­nuo
        run: |
          echo "ğŸ“Š Iniciando monitoramento pÃ³s-deploy..."
          echo "â±ï¸ DuraÃ§Ã£o: 10 minutos"
          echo "ğŸ¯ MÃ©tricas observadas:"
          echo "   ğŸ“ˆ Taxa de sucesso das requisiÃ§Ãµes"
          echo "   âš¡ Tempo mÃ©dio de resposta"
          echo "   ğŸ’¾ Uso de memÃ³ria"
          echo "   ğŸ”„ Taxa de bounce"
          echo "   ğŸ› Erros JavaScript no frontend"

          # Simular monitoramento por alguns "minutos"
          for i in {1..5}; do
            echo "ğŸ” VerificaÃ§Ã£o $i/5:"
            echo "   âœ… Taxa de sucesso: 99.8%"
            echo "   âš¡ Tempo resposta: 245ms"
            echo "   ğŸ’¾ MemÃ³ria: 67% (normal)"
            echo "   ğŸ”„ Bounce rate: 23% (bom)"
            sleep 1
          done

          echo "ğŸ‰ Monitoramento concluÃ­do - Tudo funcionando perfeitamente!"

      - name: ğŸ“ˆ RelatÃ³rio final
        run: |
          echo "ğŸ“ˆ RELATÃ“RIO FINAL DO DEPLOY"
          echo "================================"
          echo "âœ… Status: SUCESSO"
          echo "ğŸ“¦ VersÃ£o deployada: ${{ needs.build.outputs.build-version }}"
          echo "â±ï¸ Tempo total pipeline: ~15 minutos"
          echo "ğŸ”„ Jobs executados: 8/8"
          echo "ğŸ§ª Testes executados: 47"
          echo "ğŸ› Bugs encontrados: 0"
          echo "ğŸ“Š Performance: Melhorou 3%"
          echo "ğŸ‘¥ Impacto: 0 usuÃ¡rios afetados"
          echo "ğŸ’° Custo: ~$0.15 (GitHub Actions)"
          echo ""
          echo "ğŸ¯ PrÃ³ximos passos:"
          echo "   - Monitorar mÃ©tricas por 24h"
          echo "   - Coletar feedback dos usuÃ¡rios"
          echo "   - Planejar prÃ³ximo release"
          echo ""
          echo "ğŸ† DEPLOY CONCLUÃDO COM SUCESSO!"

# ConfiguraÃ§Ãµes globais para todos os jobs
# Ã‰ como "regras da casa" que todos devem seguir
defaults:
  run:
    shell: bash # Usar bash como shell padrÃ£o

# Configurar permissÃµes que este workflow precisa
# Ã‰ como dizer "este pipeline precisa de permissÃ£o para fazer X"
permissions:
  contents: read # Ler cÃ³digo do repositÃ³rio
  actions: read # Ler outros workflows
  checks: write # Escrever resultados de testes
  issues: write # Comentar em issues (opcional)
  pull-requests: write # Comentar em PRs (opcional)
